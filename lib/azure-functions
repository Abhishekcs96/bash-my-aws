#!/bin/bash
# set -eu -o pipefail # I source this file and don't want my shell to exit on error.
# shellcheck disable=SC2120

# azure-functions
#
# WARNING, an experiment - alpha! - do not use!
#
# I first used the `az cli` on 25 Nov 2022 so am only at the start of a 
# learning journey.
#
# Source this file in from bash terminal and enjoy the functions.
#
# az reference: https://learn.microsoft.com/en-us/cli/azure/reference-index?view=azure-cli-latest

# Wishlist
#
# - `az login` without opening GUI web browser. username/password is an option.
# - bash completion

# Shared Functions

function debug() {
  [[ -n $DEBUG ]] && printf "$1" >&2
}

__bma_read_filters-az() {

  # Construct a string to be passed to `grep -E`
  #
  #     $ __bma_read_filters foo bar baz
  #     foo|bar|baz

  ( IFS=$'|'; printf -- "$*" )
}

function columnise ()
{
    column -t -s$'\t'
}

function skim-stdin-tsv ()
{
    # XXX Update to quote items in output
    local skimmed_stdin="$([[ -t 0 ]] || awk -F$'\t' 'ORS=" " { print $1 }')";
    printf -- '%s %s' "$*" "$skimmed_stdin" | awk '{$1=$1;print}'
}

# Copied from bash-my-aws
function skim-stdin-bma() {

  # Append first token from each line of STDIN to argument list
  #
  # Implementation of `pipe-skimming` pattern.
  #
  #     $ stacks | skim-stdin foo bar
  #     foo bar huginn mastodon grafana
  #
  #     $ stacks
  #     huginn    CREATE_COMPLETE  2020-01-11T06:18:46.905Z  NEVER_UPDATED  NOT_NESTED
  #     mastodon  CREATE_COMPLETE  2020-01-11T06:19:31.958Z  NEVER_UPDATED  NOT_NESTED
  #     grafana   CREATE_COMPLETE  2020-01-11T06:19:47.001Z  NEVER_UPDATED  NOT_NESTED
  #
  # Typical usage within Bash-my-AWS functions:
  #
  #     local asg_names=$(skim-stdin "$@") # Append to arg list
  #     local asg_names=$(skim-stdin)      # Only draw from STDIN

  local skimmed_stdin="$([[ -t 0 ]] || awk 'ORS=" " { print $1 }')"

  printf -- '%s %s' "$*" "$skimmed_stdin" |
    awk '{$1=$1;print}'  # trim leading/trailing spaces

}

# Authentication functions

function az-account() {
  az account show \
    --query ' [[ name, user.name ]]' \
    --output tsv |
  columnise
}

function az-user() {
  az ad signed-in-user show
}

# az cache functions

function az-cache-items() {
  az cache list \
  --query '[].[
    resourceGroup,
    resourceType,
    name,
    lastSaved
    ]' \
  --output tsv
}

function az-cache-item() {
  # XXX We probably want to quote args
  # Create arguments from output of az-cache-items() (if present)
  local args_from_stdin
  args_from_stdin="$([[ -t 0 ]] || awk '{ print "--resource-group=" $1, " --resource-type=" $2, " --name=" $3 }')"
  if [[ -n $1 ]]; then # if command line args provided
    if [[ -n $1 && -n $2 && -n $3 ]]; then # if >= 3 args present
      local args_from_cmd
      args_from_cmd="--resource-group=$1 --resource-type=$2 --name=$3"
    fi
  fi
  local $arg_list
  arg_list=$(printf -- '%s\n%s' "$args_from_stdin" "$args_from_cmd" ) # | awk '{$1=$1;print}')  # trim leading/trailing spaces
  echo "$arg_list"
  while read -r line; do
    az cache show $line
  done <<< "$arg_list"
}

function az-cache-item-delete() {
  # XXX We probably want to quote args
  # Create arguments from output of az-cache-items() (if present)
  local args_from_stdin
  args_from_stdin="$([[ -t 0 ]] || awk '{ print "--resource-group=" $1, " --resource-type=" $2, " --name=" $3 }')"
  if [[ -n $1 ]]; then # if command line args provided
    if [[ -n $1 && -n $2 && -n $3 ]]; then # if >= 3 args present
      local args_from_cmd
      args_from_cmd="--resource-group=$1 --resource-type=$2 --name=$3"
    fi
  fi
  local $arg_list
  arg_list=$(printf -- '%s\n%s' "$args_from_stdin" "$args_from_cmd" ) # | awk '{$1=$1;print}')  # trim leading/trailing spaces
  while read -r line; do
    az cache delete $line
  done <<< "$arg_list"
}

# Location Functions

function locations(){
  local filters=$(__bma_read_filters-az $@);
  az account list-locations \
    --query '[].[
      name,
      displayName
    ]' \
    --output tsv |
  grep -E -- "$filters" |
  LC_ALL=C sort -b -k 3 |
  columnise

}

function location() {

  local location=$(skim-stdin-tsv "$@")
  # XXX Check input is a valid location
  if [[ -z "$location" ]]; then
    az config get defaults.location \
      --only-show-errors            \
      --output tsv                  \
      --query "value"
  else
    az config set defaults.location="${location}" \
      --only-show-errors                          \
      --output tsv
  fi
}

function location-unset() {
    az config unset defaults.location
}

function location-each() {

  local locations
  if [[ -t 0 ]]; then
    locations=$(locations | awk -F$'\t' '{print $1}')
  else
    locations=$(awk 'ORS=" " { print $1 }')
  fi
  local old_azure_default_location
  old_azure_default_location="$(location)"
  local location
  for location in $locations; do
    location "$location"
    eval "$@" | sed "s/$/ #${location}/"
  done
  location "$old_azure_default_location"
}

## Resource Functions

function resource-groups() {
  local filters=$(__bma_read_filters-az $@);
  az group list \
    --query "[].[
      name,
      id,
      location
      ]" \
    --output tsv |
  grep -E -- "$filters" |
  LC_ALL=C sort -b -k 5 |
  column -s$'\t' -t
}

function resource-group() {

  local group=$(skim-stdin-bma "$@")
  # XXX Check input is a valid location
  if [[ -z "$group" ]]; then
    az config get defaults.group \
      --only-show-errors         \
      --output tsv               \
      --query "value"
  else
    az config set defaults.group="${group}" \
      --only-show-errors                          \
      --output tsv
  fi
}

function resource-group-unset() {
    az config unset defaults.group
}

function resources() {
  local filters=$(__bma_read_filters-az $@);
  az resource list                           \
    --query "[].[
      name,
      resourceGroup,
      type,
      createdTime,
      changedTime]" \
    --output tsv |
  grep -E -- "$filters" |
  LC_ALL=C sort -b -k 5 |
  column -s$'\t' -t
}

## Service Principal Functions

function service-principals() {
  local filters=$(__bma_read_filters-az $@);
  az ad sp list \
    --query "[].[
      appId,
      appOwnerTenantId,
      appDisplayName
    ]" \
    --output tsv |
    grep -E -- "$filters" |
    LC_ALL=C sort -b -k 3 |
    column -s$'\t' -t
}

## Subscription Functions

function subscriptions() {
  local filters=$(__bma_read_filters-az $@);
  az account list --all                      \
    --query "[].[
      id,
      isDefault,
      state,
      name
    ]"                                       \
    --output tsv                             |
    grep -E -- "$filters"                    |
    LC_ALL=C sort -b -k 3                    |
    column -s$'\t' -t
}

function subscription() {

  local subscription=$(skim-stdin-bma "$@")
  if [[ -z $subscription ]]; then
    subscriptions True
  else
    az account set --subscription "$subscription"
  fi
}

function subscription-unset() {
    az config unset defaults.subscription
}

function subscription-each() {

  # Ported from BMA

  local subscriptions
  if [[ -t 0 ]]; then
    subscriptions=$(subscriptions | awk -F$'\t' '{print $1}')
  else
    subscriptions=$(awk 'ORS=" " { print $1 }')
  fi
  local old_default_subscription
  old_default_subscription="$(subscription | awk '{print $1}')"
  local subscription
  for subscription in $subscriptions; do
    subscription "$subscription"
    eval "$@" | sed "s/$/ #${subscription}/"
  done
  subscription "$old_default_subscription"
}

## Resource Specific Functions

## Front Door WAF Functions

function front-door-waf-policies() {
  az network front-door waf-policy list \
    --output tsv \
    --query "[].[
      name,
      resourceGroup,
      resourceState
      ]" |
  grep -E -- "$filters" |
  LC_ALL=C sort -b -k 1 |
  column -s$'\t' -t
}

function front-door-waf-policy-rules() {

  local policies=$(skim-stdin-bma "$@")
   debug "\$policies=$policies"
  [[ -z $policies ]] && __bma_usage "policy [policy]" && return 1

  local policy
  for policy in $policies; do
    az network front-door waf-policy rule list \
      --policy-name "$policy" \
      --output tsv \
      --query "[].[
        name,
        enabledState,
        priority,
        ruleType,
        action,
        '$policy',
        '$resource_group'
      ]" |
    grep -E -- "$filters" |
    LC_ALL=C sort -b -k 1 |
    column -s$'\t' -t
  done
}

function front-door-waf-policy-rule-match-conditions() {

  local policy_name="${1}"
  shift 1
  local rule_names=$(skim-stdin "$@")

  if [[ -z $policy_name || -z $rule_names ]]; then
    echo "Usage: ${FUNCNAME[0]} POLICY_NAME RULE_NAME [RULE_NAME]" >&2
    return 1
  fi

  local rule_name
  for rule_name in $rule_names; do
    az network front-door waf-policy rule match-condition list \
      --policy-name "$policy_name"                             \
      --name "$rule_name"                                      \
      --query '[].[[
        join(`=`, [`operator`, operator]),
        join(`=`, [`matchVariable`, matchVariable]),
        join(`=`, [
          `matchValues`,
           to_string(length(matchValue))
        ]),
       `# view matches with front-door-waf-policy-rule-match-values()`
      ]][]'                                                       \
      --output tsv
  done
}

function front-door-waf-policy-rule-match-condition-values() {

  local policy_name="${1}"
  shift 1
  local rule_names=$(skim-stdin "$@")

  if [[ -z $policy_name || -z $rule_names ]]; then
    echo "Usage: ${FUNCNAME[0]} POLICY_NAME RULE_NAME [RULE_NAME]" >&2
    return 1
  fi

  local rule_name
  for rule_name in $rule_names; do
    az network front-door waf-policy rule match-condition list \
      --policy-name "$policy_name"                             \
      --name "$rule_name"                                      \
      --query '[0].[matchValue][]'                             \
      --output tsv
  done
}

function front-door-waf-policy-rule-delete() {

  local policy_name="${1:-}"
  shift
  local rule_names=$(skim-stdin-bma "$@")

  if [[ -z $policy_name || -z $rule_names ]]; then
    echo "Usage: front-door-waf-policy-rule-delete POLICY_NAME RULE_NAME [RULE_NAME]" >&2
    return 1
  fi

  echo "You are about to delete the following front-door WAF policy rules from $policy_name:"
  echo "$rule_names" | tr ' ' "\n" # | front-door-waf-policy-rules # XXX add when we have resourceGroup sorted
  [ -t 0 ] || exec </dev/tty # reattach keyboard to STDIN
  local regex_yes="^[Yy]$"
  read -p "Are you sure you want to continue? " -n 1 -r
  echo
  if [[ $REPLY =~ $regex_yes ]]
  then
    # XXX replace with `--ids` arg when we can generate resource IDs # it's easy
    for rule_name in $rule_names; do
      az network front-door waf-policy rule delete --policy-name wafPremium --name "${rule_name}"
    done
  fi
}

## AD Functions

function ad-users() {

  local filter_arg
  [[ -n $1 ]] && filter_arg='--filter "startsWith(displayName,'"'$1'"')"'

  eval "az ad user list \
    --output tsv        \
    ${filter_arg}       \
    --query '[].[
      userPrincipalName,
      displayName,
      mail
      ]'"               |
  grep -E -- "$filters" |
  LC_ALL=C sort -b -k 1 |
  column -s$'\t' -t
}
